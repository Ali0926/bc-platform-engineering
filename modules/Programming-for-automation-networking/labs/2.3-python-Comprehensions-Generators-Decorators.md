# Lab 2.3: Generators, Comprehensions, and Decorators

## Overview

Python has powerful features that make code more concise and efficient. Generators save memory, comprehensions make transformations readable, and decorators add functionality without modifying code.

In this lab, you'll learn:
- Generators with `yield` - memory-efficient iteration
- Generator expressions vs list comprehensions
- List, dictionary, and set comprehensions
- Decorators - wrapping functions with additional behavior


## Part 1: Generators - Memory-Efficient Iteration

Generators produce values on-demand using `yield` instead of storing everything in memory. Perfect for large datasets!

### Step 1: Prime Number Generator

Let's create a function that generates prime numbers and compare memory usage.

```python
import sys

def generate_primes_list(n):
    """Generate primes up to n - returns a LIST (memory intensive)"""
    primes = []
    
    for i in range(2, n + 1):
        is_prime = False
        for p in range(2, int(i ** 0.5) + 1):
            if i % p == 0:
                break
        else: # else on a for runs only if the loop is never broken
            is_prime = True
        if is_prime:
            primes.append(i)
    
    return primes

def generate_primes_generator(n):
    """Generate primes up to n - YIELDS values (memory efficient)"""
    
    for i in range(2, n + 1):
        is_prime = True
        for p in range(2, int(i ** 0.5) + 1):
            if i % p == 0:
                is_prime = False
                break
        if is_prime:
            yield i  # Key difference - yield instead of storing!

# Compare memory usage
print("=" * 50)
print("MEMORY COMPARISON")
print("=" * 50)

# List version - stores ALL primes in memory
primes_list = generate_primes_list(10000)
list_size = sys.getsizeof(primes_list)
print(f"List of 10,000 primes: {list_size:,} bytes")

# Generator version - stores only the generator object
primes_gen = generate_primes_generator(10000)
gen_size = sys.getsizeof(primes_gen)
print(f"Generator object: {gen_size:,} bytes")

print(f"\nMemory savings: {list_size / gen_size:.1f}x smaller!")

# Generators are consumed on-the-fly
print("\n" + "=" * 50)
print("USING THE GENERATOR")
print("=" * 50)

# Get first 10 primes
primes_gen = generate_primes_generator(10)
first_10 = list(primes_gen)  # Convert to list to see them
print(f"First 10 primes: {first_10}")

# Or iterate without converting
print("\nFirst 20 primes (one at a time):")
for i, prime in enumerate(generate_primes_generator(20), 1):
    print(f"{i}. {prime}")
```

**Output:** (may be different on your machine)
```
==================================================
MEMORY COMPARISON
==================================================
List of 10,000 primes: 87,624 bytes
Generator object: 112 bytes

Memory savings: 782.4x smaller!

==================================================
USING THE GENERATOR
==================================================
First 10 primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

First 20 primes (one at a time):
1. 2
2. 3
3. 5
...
```

**Key insight:** The generator object is tiny (~112 bytes) regardless of how many values it will produce. Perfect for memory-constrained environments!

### Step 2: Understanding `yield`

```python
def simple_generator():
    """Demonstrates how yield works"""
    print("Starting...")
    yield 1
    print("Between yields...")
    yield 2
    print("Almost done...")
    yield 3
    print("Generator exhausted!")

# Create generator
gen = simple_generator()
print(f"Generator created: {gen}")
print(f"Type: {type(gen)}")

# Each next() call runs until the next yield
print("\nCalling next():")
print(f"First: {next(gen)}")
print(f"Second: {next(gen)}")
print(f"Third: {next(gen)}")

# Try to get another - generator is exhausted!
try:
    print(f"Fourth: {next(gen)}")
except StopIteration:
    print("StopIteration raised - no more values!")
```

**Output:**
```
Generator created: <generator object simple_generator at 0x7f...>
Type: <class 'generator'>

Calling next():
Starting...
First: 1
Between yields...
Second: 2
Almost done...
Third: 3
Generator exhausted!
StopIteration raised - no more values!
```

**Key concept:** `yield` pauses the function and returns a value. Next call resumes where it left off.


## Part 2: Generator Expressions and Comprehensions

Python has syntactic sugar for creating generators and collections quickly.

### Step 1: Generator Expressions (the secret!)

```python
# Generator expression - uses parentheses ()
gen_exp = (x ** 2 for x in range(10))

print(f"Generator expression: {gen_exp}")
print(f"Type: {type(gen_exp)}")
print(f"Memory: {sys.getsizeof(gen_exp)} bytes")

# It's a generator! Consumes values lazily
print(f"Values: {list(gen_exp)}")

print()

# List comprehension - uses square brackets []
list_comp = [x ** 2 for x in range(10)]

print(f"List comprehension: {list_comp}")
print(f"Type: {type(list_comp)}")
print(f"Memory: {sys.getsizeof(list_comp)} bytes")

print()
print("=" * 50)
print("THE TRUTH: List comprehension is just:")
print("  list( (x for x in range(10)) )")
print("It's a generator expression cast to a list!")
print("=" * 50)
```

**Output:**
```
Generator expression: <generator object <genexpr> at 0x7f...>
Type: <class 'generator'>
Memory: 112 bytes

Values: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

List comprehension: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Type: <class 'list'>
Memory: 184 bytes

==================================================
THE TRUTH: List comprehension is just:
  list( (x for x in range(10)) )
It's a generator expression cast to a list!
==================================================
```

### Step 2: When to Use Each

```python
# Use generator expression when:
# - Processing large datasets
# - Values consumed once
# - Memory is constrained

# Sum of squares (no need to store list)
total = sum(x ** 2 for x in range(1000000))
print(f"Sum: {total}")

# Use list comprehension when:
# - Need to iterate multiple times
# - Need to index/slice
# - Dataset fits in memory

squares = [x ** 2 for x in range(10)]
print(f"First square: {squares[0]}")
print(f"Last square: {squares[-1]}")
print(f"Middle squares: {squares[3:7]}")
```

---

## Part 3: List Comprehensions

Comprehensions are concise ways to create collections. They're faster and more readable than loops.

### Step 1: Basic List Comprehension

```python
# The old way (verbose)
squares = []
for x in range(10):
    squares.append(x ** 2)

print(f"Old way: {squares}")

# The comprehension way (concise)
squares = [x ** 2 for x in range(10)]
print(f"Comprehension: {squares}")

# With filtering
evens = [x for x in range(20) if x % 2 == 0]
print(f"Even numbers: {evens}")

# With transformation and filtering
even_squares = [x ** 2 for x in range(20) if x % 2 == 0]
print(f"Squares of evens: {even_squares}")
```

### Step 2: Practical Examples

```python
# Network devices
devices = [
    {"hostname": "router1", "ip": "10.0.0.1", "status": "up"},
    {"hostname": "switch1", "ip": "10.0.0.2", "status": "down"},
    {"hostname": "router2", "ip": "10.0.0.3", "status": "up"},
    {"hostname": "switch2", "ip": "10.0.0.4", "status": "up"},
]

# Get all hostnames
hostnames = [device["hostname"] for device in devices]
print(f"Hostnames: {hostnames}")

# Get IPs of devices that are up
active_ips = [device["ip"] for device in devices if device["status"] == "up"]
print(f"Active IPs: {active_ips}")

# Transform strings
names = ["alice", "bob", "charlie"]
uppercase = [name.upper() for name in names]
print(f"Uppercase: {uppercase}")

# Parse and transform
log_lines = ["ERROR: failed", "INFO: success", "ERROR: timeout"]
errors = [line.split(": ")[1] for line in log_lines if line.startswith("ERROR")]
print(f"Error messages: {errors}")
```

### Step 3: Nested List Comprehension

```python
# Flatten a matrix (2D list to 1D list)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# The verbose way
flattened = []
for row in matrix:
    for num in row:
        flattened.append(num)

print(f"Flattened (verbose): {flattened}")

# The comprehension way
flattened = [num for row in matrix for num in row]
print(f"Flattened (comprehension): {flattened}")

# Read it as: "for each row in matrix, for each num in that row"

# With filtering
even_only = [num for row in matrix for num in row if num % 2 == 0]
print(f"Even numbers only: {even_only}")

# Create multiplication table
mult_table = [[i * j for j in range(1, 6)] for i in range(1, 6)]
print("\nMultiplication table:")
for row in mult_table:
    print(row)
```

**Output:**
```
Flattened (verbose): [1, 2, 3, 4, 5, 6, 7, 8, 9]
Flattened (comprehension): [1, 2, 3, 4, 5, 6, 7, 8, 9]
Even numbers only: [2, 4, 6, 8]

Multiplication table:
[1, 2, 3, 4, 5]
[2, 4, 6, 8, 10]
[3, 6, 9, 12, 15]
[4, 8, 12, 16, 20]
[5, 10, 15, 20, 25]
```

---

## Part 4: Dictionary and Set Comprehensions

### Step 1: Dictionary Comprehensions

```python
# Create dictionary from list
numbers = [1, 2, 3, 4, 5]
squares_dict = {x: x ** 2 for x in numbers}
print(f"Squares dict: {squares_dict}")

# Transform existing dictionary
devices = {
    "router1": "10.0.0.1",
    "switch1": "10.0.0.2",
    "router2": "10.0.0.3"
}

# Swap keys and values
ip_to_device = {ip: hostname for hostname, ip in devices.items()}
print(f"IP to device: {ip_to_device}")

# Filter dictionary
routers_only = {name: ip for name, ip in devices.items() if name.startswith("router")}
print(f"Routers only: {routers_only}")

# Transform values
uppercase_devices = {name.upper(): ip for name, ip in devices.items()}
print(f"Uppercase names: {uppercase_devices}")
```

**Output:**
```
Squares dict: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
IP to device: {'10.0.0.1': 'router1', '10.0.0.2': 'switch1', '10.0.0.3': 'router2'}
Routers only: {'router1': '10.0.0.1', 'router2': '10.0.0.3'}
Uppercase names: {'ROUTER1': '10.0.0.1', 'SWITCH1': '10.0.0.2', 'ROUTER2': '10.0.0.3'}
```

### Step 2: Set Comprehensions

```python

# Transform and deduplicate
words = ["hello", "world", "hello", "python"]
uppercase_unique = {word.upper() for word in words}
print(f"Unique uppercase: {uppercase_unique}")

# Extract unique values from nested structure
devices = [
    {"hostname": "router1", "location": "us-east"},
    {"hostname": "switch1", "location": "us-west"},
    {"hostname": "router2", "location": "us-east"},
]

locations = {device["location"] for device in devices}
print(f"Unique locations: {locations}")
```

## Part 5: Decorators - Function Wrappers

Decorators add functionality to functions without modifying their code. They're just functions that take a function and return a new function!

### Step 1: Understanding the Pattern

```python
def simple_function():
    """A simple function"""
    return "Hello!"

def uppercase_decorator(func):
    """
    Decorator that makes function return uppercase
    Takes a function, returns a new function
    """
    def wrapper():
        # Call original function
        result = func()
        # Modify result
        return result.upper()
    
    return wrapper

# Manual decoration
original = simple_function
decorated = uppercase_decorator(original)

print(f"Original: {original()}")
print(f"Decorated: {decorated()}")

print()
print("=" * 50)
print("DECORATORS ARE JUST FUNCTION WRAPPERS!")
print("decorated = uppercase_decorator(original)")
print("=" * 50)
```

**Output:**
```
Original: Hello!
Decorated: HELLO!

==================================================
DECORATORS ARE JUST FUNCTION WRAPPERS!
decorated = uppercase_decorator(original)
==================================================
```

### Step 2: The @ Syntax (Syntactic Sugar)

```python
# The @ syntax is just sugar for the pattern above

def uppercase_decorator(func):
    """Uppercase decorator"""
    def wrapper():
        return func().upper()
    return wrapper

# Using @ syntax
@uppercase_decorator
def greet():
    """Greet someone"""
    return "hello, world!"

# This is EXACTLY the same as:
# def greet():
#     return "hello, world!"
# greet = uppercase_decorator(greet)

print(f"Result: {greet()}")

# Multiple decorators stack
def exclamation_decorator(func):
    """Add exclamation marks"""
    def wrapper():
        return func() + "!!!"
    return wrapper

@exclamation_decorator
@uppercase_decorator
def shout():
    return "python is awesome"

# Order matters! Read bottom-to-top:
# 1. uppercase_decorator wraps shout
# 2. exclamation_decorator wraps the result

print(f"Shouting: {shout()}")
```

**Output:**
```
Result: HELLO, WORLD!
Shouting: PYTHON IS AWESOME!!!
```

### Step 3: Practical Decorator - Timing Functions

```python
import time

def timing_decorator(func):
    """Measure function execution time"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timing_decorator
def slow_function():
    """Simulate slow operation"""
    time.sleep(1)
    return "Done!"

@timing_decorator
def fast_function():
    """Quick operation"""
    return sum(range(1000))

print(slow_function())
print(f"Result: {fast_function()}")
```

**Output:**
```
slow_function took 1.0012 seconds
Done!
fast_function took 0.0001 seconds
Result: 499500
```

### Step 4: Decorator with Arguments

```python
def repeat_decorator(times):
    """Decorator that repeats function execution"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat_decorator(3)
def greet(name):
    return f"Hello, {name}!"

result = greet("Alice")
print(result)
```

**Output:**
```
['Hello, Alice!', 'Hello, Alice!', 'Hello, Alice!']
```

### Step 5: Real-World Example - Logging Decorator

```python
import functools

def log_calls(func):
    """Log function calls with arguments"""
    @functools.wraps(func)  # Preserves original function metadata
    def wrapper(*args, **kwargs):
        args_str = ", ".join(repr(arg) for arg in args)
        kwargs_str = ", ".join(f"{k}={v!r}" for k, v in kwargs.items())
        all_args = ", ".join(filter(None, [args_str, kwargs_str]))
        
        print(f"Calling {func.__name__}({all_args})")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result!r}")
        return result
    
    return wrapper

@log_calls
def add(a, b):
    """Add two numbers"""
    return a + b

@log_calls
def greet(name, greeting="Hello"):
    """Greet someone"""
    return f"{greeting}, {name}!"

# Test the decorated functions
result1 = add(5, 3)
print()
result2 = greet("Alice")
print()
result3 = greet("Bob", greeting="Hi")
```

**Output:**
```
Calling add(5, 3)
add returned 8

Calling greet('Alice')
greet returned 'Hello, Alice!'

Calling greet('Bob', greeting='Hi')
greet returned 'Hi, Bob!'
```

---

## Part 6: Hands-On Challenge

Create a network log analyzer using generators, comprehensions, and decorators!

**Requirements:**

1. **Generator function** `parse_log_file(filename)`:
   - Yields log entries line-by-line
   - Each entry is a dict: `{"timestamp": "...", "level": "...", "message": "..."}`

2. **Use comprehensions** to:
   - Extract all ERROR messages (list comprehension)
   - Count messages per level 
   - Get unique IP addresses from messages (set comprehension)

3. **Create decorator**:
   - `@timer` - measure function execution time

4. **Sample log format**:
   ```
   2024-01-01 10:00:00 INFO Server started on 192.168.1.10
   2024-01-01 10:01:23 ERROR Connection failed from 10.0.0.5
   2024-01-01 10:02:45 WARN High memory usage
   2024-01-01 10:03:12 ERROR Timeout from 10.0.0.5
   ```

**Bonus:** Use nested list comprehension to extract all IP addresses (v4 format: xxx.xxx.xxx.xxx) from all messages.

---

## Success Criteria

You've completed this lab when you can:

- [ ] Write generator functions with `yield`
- [ ] Explain memory benefits of generators vs lists
- [ ] Use `sys.getsizeof()` to measure memory
- [ ] Create generator expressions with `()`
- [ ] Explain that list comprehensions are generators cast to lists
- [ ] Write list comprehensions with filtering
- [ ] Write dictionary and set comprehensions
- [ ] Create decorators that wrap functions
- [ ] Explain that `@decorator` is syntactic sugar
- [ ] Combine generators, comprehensions, and decorators

---

## Key Takeaways

**What you learned:**

**Generators:**
- `yield` pauses and resumes functions
- Use ~100 bytes regardless of data size
- Perfect for large datasets, streams, infinite sequences
- Many Python built-ins return generators (`range()`, `map()`, `filter()`, file iteration)

**Comprehensions:**
- List `[]` - ordered, allows duplicates, stored in memory
- Set `{}` - unordered, unique values, stored in memory
- Dict `{k: v}` - key-value pairs, stored in memory
- Generator `()` - lazy evaluation, minimal memory
- All are faster and more readable than loops

**Decorators:**
- Functions that take a function and return a function
- `@decorator` is sugar for `func = decorator(func)`
- Add functionality without modifying code
- Common uses: timing, logging, authentication, caching
- Can stack multiple decorators

**Why this matters:**
- **Memory-efficient scripts** - process GB files with MB of RAM
- **Cleaner code** - comprehensions are idiomatic Python
- **Reusable functionality** - decorators separate concerns
- **Performance** - generators and comprehensions are optimized in CPython
- **Interview questions** - these are common topics

**Next steps:** Use these patterns in automation scripts. Generators for log processing, comprehensions for data transformation, decorators for cross-cutting concerns.

---

## Quick Reference

```python
# Generators
def my_generator():
    yield 1
    yield 2

gen = (x for x in range(10))  # Generator expression

# Comprehensions
list_comp = [x for x in range(10) if x % 2 == 0]
dict_comp = {x: x ** 2 for x in range(10)}
set_comp = {x % 3 for x in range(10)}

# Decorators
def decorator(func):
    def wrapper(*args, **kwargs):
        # Before
        result = func(*args, **kwargs)
        # After
        return result
    return wrapper

@decorator
def my_func():
    pass

# Same as: my_func = decorator(my_func)
```

---

## Additional Resources

- [PEP 289 - Generator Expressions](https://www.python.org/dev/peps/pep-0289/)
- [PEP 318 - Decorators](https://www.python.org/dev/peps/pep-0318/)
- [Python Generator Tutorial](https://realpython.com/introduction-to-python-generators/)
- [Comprehensions Guide](https://realpython.com/list-comprehension-python/)
- [Decorator Primer](https://realpython.com/primer-on-python-decorators/)

---

**Congratulations!** You now understand Python's most powerful productivity features - generators, comprehensions, and decorators!
