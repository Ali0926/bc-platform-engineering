# Lab 4.1: OpenTelemetry with FastAPI (Hands-On)

## Overview

In this lab, you will learn how OpenTelemetry (OTEL) works in a real FastAPI system by verifying each part of the tracing pipeline end-to-end.

By the end of this lab, you will understand:

- How OTEL auto-instrumentation works
- How traces leave your app and reach Tempo
- How service identity and sampling work
- How to create and interpret custom spans
- How distributed tracing context propagates

This lab focuses on observability as a system, not just theory.

---

## System Architecture

Your tracing pipeline looks like this:

Client Request → FastAPI/Uvicorn → OTEL Auto-Instrumentation → OTLP Exporter → Tempo → Grafana

Each part must work for traces to appear.

---

## Step 1: Understand the Startup Script

Open and review:

```bash
apps/fastapi/src/run.sh
```

```bash
#!/bin/bash

export OTEL_SERVICE_NAME="fastapi-app"
export OTEL_TRACES_EXPORTER="otlp"
export OTEL_METRICS_EXPORTER="none"
export OTEL_LOGS_EXPORTER="none"

export OTEL_EXPORTER_OTLP_TRACES_ENDPOINT="http://tempo:4318/v1/traces"
export OTEL_EXPORTER_OTLP_PROTOCOL="http/protobuf"

export OTEL_PYTHON_LOG_CORRELATION="true"
export OTEL_TRACES_SAMPLER="parentbased_always_on"

exec opentelemetry-instrument uvicorn main:app --host 0.0.0.0 --port 8000
```

### What this actually means

| Variable | Purpose |
|---------|--------|
| `OTEL_SERVICE_NAME` | How this service appears in Tempo |
| `OTEL_TRACES_EXPORTER` | Enables trace exporting |
| `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT` | Where traces are sent |
| `OTEL_TRACES_SAMPLER` | 100% sampling |
| `opentelemetry-instrument` | Injects OTEL into the app process |

This command wraps Uvicorn and auto-instruments FastAPI and supported libraries.

No manual span code is required for basic tracing.

---

## Step 2: Verify Tempo Connectivity

You must confirm your app can reach Tempo.

From inside the FastAPI container or pod:

```bash
kubectl exec -it deploy/fastapi -- sh
```

Then:

```bash
getent hosts tempo
curl http://tempo:4318/
```

If this fails, tracing cannot work.

---

## Step 3: Generate Traces

Start the app:

```bash
./src/run.sh
```

Send requests:

```bash
curl http://localhost:8000/health
curl http://localhost:8000/items
curl http://localhost:8000/items
```

Now open Grafana → Explore → Tempo datasource.

Filter by:

```
service.name = fastapi-app
```

You should see traces for each request.

---

## Step 4: Prove Service Identity

Change in `run.sh`:

```bash
export OTEL_SERVICE_NAME="fastapi-lab-4-1"
```

Restart the app and generate traffic again.

In Grafana, you should now see:

```
service.name = fastapi-lab-4-1
```

This proves your service identity is wired correctly.

---

## Step 5: Add Teaching Spans

Open `main.py` and add:

```python
import time
from fastapi import FastAPI
from opentelemetry import trace

app = FastAPI()
tracer = trace.get_tracer(__name__)

@app.get("/lab/span-demo")
def span_demo(ms: int = 150, fail: bool = False):
    with tracer.start_as_current_span("business_logic") as span:
        span.set_attribute("demo.ms", ms)
        time.sleep(ms / 1000)

        with tracer.start_as_current_span("downstream_work"):
            time.sleep(0.05)

        if fail:
            raise RuntimeError("boom (intentional)")

    return {"ok": True, "slept_ms": ms, "fail": fail}
```

Run:

```bash
curl "http://localhost:8000/lab/span-demo?ms=400"
curl "http://localhost:8000/lab/span-demo?fail=true"
```

In Tempo you should see:

- Parent request span
- Nested `business_logic` span
- Nested `downstream_work` span
- Error trace for failing request

This is real distributed tracing structure.

---

## Step 6: Prove Context Propagation

Run:

```bash
curl -H "traceparent: 00-11111111111111111111111111111111-2222222222222222-01"   http://localhost:8000/items
```

In Tempo:

- The trace ID should start with `111111...`

This proves your service honors incoming trace context.

---

## Step 7: Auto-Instrumentation Limitations

Auto-instrumentation only works for libraries that have OTEL support.

Example:

```python
import httpx

@app.get("/lab/http-child")
def http_child():
    r = httpx.get("https://example.com")
    return {"status": r.status_code}
```

If HTTP client instrumentation is installed, you will see a child span:

HTTP GET example.com

If not, no child span appears.

This teaches an important rule:

Auto-instrumentation is only as good as the installed instrumentation packages.

---

## Step 8: How Errors Appear in Traces

Any uncaught exception:

- Marks the span as ERROR
- Records the exception
- Makes the trace searchable by error

This is how modern systems debug production failures.

---

## What You Should Now Understand

You now know:

- How OTEL is injected into a Python process
- How traces flow to Tempo
- How service identity works
- How sampling affects visibility
- How to create custom spans
- How context propagates
- Why auto-instrumentation has limits

You are no longer using OTEL.

You are operating a tracing system.

---

## Real-World Mapping

| Concept | Real Production Equivalent |
|--------|----------------------------|
| Tempo | Datadog / New Relic / Honeycomb |
| OTLP | Industry standard protocol |
| Custom spans | Business transactions |
| Trace context | Service mesh propagation |
| Error traces | Incident root cause |
| Service identity | Microservice topology |

---

## Takeaway

OpenTelemetry is not a tool.

It is a control plane for observability.

Once you understand the pipeline, every vendor product becomes trivial to use.
